# =============================================================================
# RETAIL INSIGHTS DASHBOARD — Professional Streamlit App
# Run with: streamlit run app_professional.py
# =============================================================================

import os

import numpy as np
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import streamlit as st

# ─── Configuration ────────────────────────────────────────────────────────────
st.set_page_config(
    page_title="Retail Insights Dashboard",
    layout="wide",
    initial_sidebar_state="expanded",
)

# ─── Color Palette (Consistent throughout) ───────────────────────────────────
COLORS = {
    "primary": "#818991",     
    "secondary": "#3b82f6",    
    "accent": "#10b981",       
    "warning": "#f59e0b",      
    "danger": "#ef4444",      
    "neutral": "#6b7280",     
    "background": "#f8fafc",   
    "card_bg": "#ffffff",      
}

COLOR_SCALE = [
    COLORS["primary"],
    COLORS["secondary"], 
    COLORS["accent"],
    COLORS["warning"]
]

# ─── Custom CSS ───────────────────────────────────────────────────────────────
st.markdown(
    f"""
<style>
    /* Metric cards with consistent gradient */
    .metric-card {{
        background: linear-gradient(135deg, {COLORS["primary"]} 0%, {COLORS["secondary"]} 100%);
        border-radius: 12px;
        padding: 20px;
        color: white;
        text-align: center;
        margin: 8px 0;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        transition: transform 0.2s;
    }}
    .metric-card:hover {{
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0,0,0,0.15);
    }}
    .metric-value {{ 
        font-size: 2em; 
        font-weight: 700;
        margin: 8px 0;
    }}
    .metric-label {{ 
        font-size: 0.9em; 
        opacity: 0.95;
        font-weight: 500;
    }}
    
    /* Insight boxes */
    .insight-box {{
        background: linear-gradient(to right, {COLORS["background"]}, white);
        border-left: 5px solid {COLORS["accent"]};
        padding: 16px 20px;
        border-radius: 0 10px 10px 0;
        margin: 16px 0;
        font-size: 0.95em;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }}
    
    /* KPI help box with tooltip styling */
    .kpi-help {{
        background: {COLORS["card_bg"]};
        border: 2px solid {COLORS["secondary"]};
        border-radius: 10px;
        padding: 12px 16px;
        margin: 8px 0;
        font-size: 0.9em;
        color: {COLORS["neutral"]};
        box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }}
    .kpi-help-title {{
        font-weight: 600;
        color: {COLORS["primary"]};
        margin-bottom: 6px;
        font-size: 1em;
    }}
    
    /* Consistent heading colors */
    h1 {{ 
        color: {COLORS["primary"]}; 
        font-weight: 700;
    }}
    h2 {{ 
        color: {COLORS["primary"]}; 
        font-weight: 600;
    }}
    h3 {{ 
        color: {COLORS["secondary"]}; 
        font-weight: 600;
    }}
    
    /* Sidebar styling */
    [data-testid="stSidebar"] {{
        background: linear-gradient(180deg, {COLORS["primary"]} 0%, {COLORS["secondary"]} 100%);
    }}
    [data-testid="stSidebar"] .stRadio label {{
        color: white !important;
    }}
    
    /* Button styling */
    .stButton>button {{
        background: {COLORS["accent"]};
        color: white;
        border-radius: 8px;
        border: none;
        padding: 8px 24px;
        font-weight: 600;
    }}
    .stButton>button:hover {{
        background: {COLORS["primary"]};
    }}
</style>
""",
    unsafe_allow_html=True,
)

# ─── Helper Functions ─────────────────────────────────────────────────────────
def show_kpi_help(title, description):
    """Display help bubble explaining a KPI"""
    st.markdown(
        f"""
        <div class="kpi-help">
            <div class="kpi-help-title">{title}</div>
            <div>{description}</div>
        </div>
        """,
        unsafe_allow_html=True,
    )

def create_insight_box(text):
    """Create styled insight box"""
    st.markdown(
        f"""
        <div class="insight-box">
            {text}
        </div>
        """,
        unsafe_allow_html=True,
    )

# ─── Data Loading ─────────────────────────────────────────────────────────────
@st.cache_data
def load_data():
    """Load all CSV files generated by the ML pipeline."""
    data = {}
    files = {
        "rules": "results/association_rules.csv",
        "segments": "results/customer_segments.csv",
        "revenue": "results/revenue_simulation.csv",
        "promotion": "results/promotion_efficiency.csv",
        "top_prod": "results/top_products.csv",
        "algo_comp": "results/algorithm_comparison.csv",
        "reorder": "results/reorder_by_department.csv",
        "utility": "results/utility_rules.csv",
        "segment_profiles": "results/segment_profiles.csv",
        "dept_summary": "results/department_rules_summary.csv",
    }
    for key, path in files.items():
        if os.path.exists(path):
            data[key] = pd.read_csv(path)
        else:
            data[key] = None
    return data

data = load_data()

# ─── Sidebar ──────────────────────────────────────────────────────────────────
with st.sidebar:
    st.markdown("# Retail Insights")
    st.markdown("**Data-Driven Analysis Platform**")
    st.divider()

    page = st.radio(
        "Navigation",
        [
            "Overview",
            "Customer Segments",
            "Product Associations",
            "Revenue Simulation",
            "Promotion ROI",
        ],
        label_visibility="visible"
    )

    st.divider()
    st.markdown("**Dataset Statistics**")
    st.caption("3M+ orders analyzed")
    st.caption("200K+ unique customers")
    st.caption("50K+ products")
    st.caption("Instacart Online Grocery")

# ─── Helper: check data ───────────────────────────────────────────────────────
def data_missing(key, fname):
    if data[key] is None:
        st.warning(f"Run `instacart_enhanced.py` first to generate `{fname}`.")
        return True
    return False

# =============================================================================
# PAGE 1: OVERVIEW
# =============================================================================
if page == "Overview":
    st.title("Retail Insights Dashboard")
    st.markdown("Data-driven analysis of customer behavior, product bundles, and revenue impact.")
    st.divider()

    # ─── Main KPI Row ─────────────────────────────────────────────────────────
    col1, col2, col3, col4 = st.columns(4)

    n_customers = (
        data["segments"]["user_id"].nunique() if data["segments"] is not None else None
    )
    n_rules = len(data["rules"]) if data["rules"] is not None else None

    if data["revenue"] is not None:
        total_gain = data["revenue"]["net_revenue_gain"].sum()
        gain_str = f"${total_gain:,.0f}"
    else:
        gain_str = "N/A"

    if data["promotion"] is not None:
        promo_overview = data["promotion"].copy()
        if "advantage" in promo_overview.columns:
            targeting_adv = promo_overview["advantage"].sum()
            adv_str = f"${targeting_adv:,.0f}"
        else:
            adv_str = "N/A"
    else:
        adv_str = "N/A"

    with col1:
        st.metric(
            "Customers Analyzed",
            f"{n_customers:,}" if isinstance(n_customers, (int, np.integer)) else "N/A",
        )
    with col2:
        st.metric(
            "Association Rules",
            f"{n_rules:,}" if isinstance(n_rules, (int, np.integer)) else "N/A",
        )
    with col3:
        st.metric("Estimated Net Revenue Gain", gain_str)
    with col4:
        st.metric("Targeting Advantage", adv_str)

    # ─── KPI Explanations ─────────────────────────────────────────────────────
    with st.expander("Understanding Key Metrics", expanded=False):
        col1, col2 = st.columns(2)
        
        with col1:
            show_kpi_help(
                "Customers Analyzed",
                "Total unique customers in the segmentation analysis. These customers have "
                "at least 3 orders and represent the active customer base."
            )
            show_kpi_help(
                "Association Rules",
                "Number of purchase patterns discovered by the FP-Growth algorithm. Each rule "
                "identifies products frequently bought together (e.g., 'Bananas → Milk' with "
                "85% confidence)."
            )
        
        with col2:
            show_kpi_help(
                "Estimated Net Revenue Gain",
                "Incremental net revenues after deducting promotion costs. Calculated as: "
                "(Lift Revenue × Average Price) - Discount Costs. Based on product associations "
                "and observed purchase behaviors."
            )
            show_kpi_help(
                "Targeting Advantage",
                "P&L difference between targeted promotions (based on segments) and blanket "
                "promotions (identical for everyone). Measures the effectiveness of data-driven "
                "targeting vs traditional approaches."
            )

    st.divider()

    # ─── Main Charts ──────────────────────────────────────────────────────────
    col_l, col_r = st.columns(2)

    # Top Products
    with col_l:
        st.subheader("Top 10 Most Ordered Products")
        if not data_missing("top_prod", "results/top_products.csv"):
            tp = data["top_prod"].copy()
            if not tp.empty:
                fig = px.bar(
                    tp.head(10).sort_values("order_count"),
                    x="order_count",
                    y="product_name",
                    orientation="h",
                    color="order_count",
                    color_continuous_scale=[[0, COLORS["secondary"]], [1, COLORS["primary"]]],
                    labels={"order_count": "Number of Orders", "product_name": ""},
                )
                fig.update_layout(
                    height=420, 
                    showlegend=False, 
                    coloraxis_showscale=False,
                    plot_bgcolor="white",
                    paper_bgcolor="white"
                )
                fig.update_xaxes(showgrid=True, gridcolor="#f0f0f0")
                st.plotly_chart(fig, use_container_width=True)
                
                st.caption("Fresh produce and dairy products dominate order frequency.")
            else:
                st.info("Top products table is empty.")

    # Algorithm Comparison
    with col_r:
        st.subheader("Algorithm Performance Comparison")
        if not data_missing("algo_comp", "results/algorithm_comparison.csv"):
            ac = data["algo_comp"].copy()
            if not ac.empty:
                fig = make_subplots(specs=[[{"secondary_y": True}]])
                fig.add_trace(
                    go.Bar(
                        x=ac["Algorithm"],
                        y=ac["Itemsets"],
                        name="Itemsets Found",
                        marker_color=COLORS["primary"],
                    )
                )
                fig.add_trace(
                    go.Scatter(
                        x=ac["Algorithm"],
                        y=ac["Time (s)"],
                        name="Time (s)",
                        mode="lines+markers",
                        line=dict(color=COLORS["accent"], width=3),
                        marker=dict(size=10),
                    ),
                    secondary_y=True,
                )
                fig.update_layout(
                    height=420,
                    plot_bgcolor="white",
                    paper_bgcolor="white"
                )
                fig.update_yaxes(title_text="Number of Itemsets", secondary_y=False)
                fig.update_yaxes(title_text="Execution Time (s)", secondary_y=True)
                st.plotly_chart(fig, use_container_width=True)
                
                st.caption("FP-Growth demonstrates 2-5x faster execution than Apriori on large datasets.")
            else:
                st.info("Algorithm comparison table is empty.")

    # ─── Key Insight ──────────────────────────────────────────────────────────
    create_insight_box(
        "<strong>Business Impact:</strong> Strong association rules combined with efficient "
        "FP-Growth execution enable regular recommendation updates on large retail datasets. "
        "High-value bundles can directly inform pricing and promotion strategies rather than "
        "remaining at the exploratory stage."
    )

    # ─── Additional Statistics ────────────────────────────────────────────────
    if data["segment_profiles"] is not None:
        st.divider()
        st.subheader("Segmentation Overview")
        
        profiles = data["segment_profiles"].copy()
        if not profiles.empty:
            col1, col2, col3 = st.columns(3)
            
            with col1:
                n_segments = len(profiles)
                st.metric("Segments Identified", n_segments)
            
            with col2:
                if "count" in profiles.columns:
                    avg_size = profiles["count"].mean()
                    st.metric("Average Segment Size", f"{avg_size:,.0f}")
            
            with col3:
                if "monetary" in profiles.columns:
                    avg_value = profiles["monetary"].mean()
                    st.metric("Average Customer Value", f"${avg_value:,.0f}")

# =============================================================================
# PAGE 2: CUSTOMER SEGMENTS
# =============================================================================
elif page == "Customer Segments":
    st.title("Customer Segmentation")
    st.markdown("RFM (Recency, Frequency, Monetary) analysis with K-Means clustering enriched by diversity metrics.")
    st.divider()

    if data_missing("segments", "results/customer_segments.csv"):
        st.stop()

    seg = data["segments"].copy()
    if seg.empty:
        st.info("Customer segments table is empty.")
        st.stop()

    # ─── Segment Statistics ───────────────────────────────────────────────────
    seg_cols = ["frequency", "recency", "monetary"]
    
    # Add diversity columns if available
    diversity_cols = []
    for col in ["unique_products", "unique_departments", "diversity_index", "exploration_rate"]:
        if col in seg.columns:
            diversity_cols.append(col)
            seg_cols.append(col)
    
    seg_summary = seg.groupby("segment").agg({
        "user_id": "count",
        **{col: "mean" for col in seg_cols}
    }).reset_index()
    
    seg_summary.columns = ["segment", "Customers"] + [col.replace("_", " ").title() for col in seg_cols]
    seg_summary = seg_summary.round(1)

    # ─── Segmentation Explanations ────────────────────────────────────────────
    with st.expander("Understanding RFM+ Segmentation", expanded=False):
        col1, col2 = st.columns(2)
        
        with col1:
            show_kpi_help(
                "Frequency",
                "Average number of orders per customer in the segment. Higher values indicate "
                "regular, loyal customers."
            )
            show_kpi_help(
                "Recency",
                "Average number of days between orders. Lower values indicate recently active "
                "customers."
            )
            show_kpi_help(
                "Monetary Value",
                "Total estimated purchase value per customer. Higher values indicate high-value "
                "customers."
            )
        
        with col2:
            show_kpi_help(
                "Unique Products",
                "Average number of different products purchased. Measures basket width."
            )
            show_kpi_help(
                "Unique Departments",
                "Average number of categories visited. Indicates cross-category engagement."
            )
            show_kpi_help(
                "Diversity Index",
                "Shannon entropy of purchases across departments. Higher values indicate more "
                "diversified baskets (exploratory behavior)."
            )

    st.divider()

    # ─── Visualizations ───────────────────────────────────────────────────────
    col1, col2 = st.columns([1, 1.5])

    with col1:
        st.subheader("Segment Distribution")
        fig = px.pie(
            seg_summary,
            names="segment",
            values="Customers",
            color_discrete_sequence=COLOR_SCALE,
            hole=0.4,
        )
        fig.update_layout(
            height=400,
            paper_bgcolor="white",
            plot_bgcolor="white"
        )
        fig.update_traces(textposition='inside', textinfo='percent+label')
        st.plotly_chart(fig, use_container_width=True)

    with col2:
        st.subheader("Segment Profiles")
        display_cols = ["segment", "Customers", "Frequency", "Recency", "Monetary"]
        display_df = seg_summary[display_cols].rename(columns={
            "segment": "Segment",
            "Customers": "Customers",
            "Frequency": "Orders",
            "Recency": "Days Between Orders",
            "Monetary": "Total Spend ($)"
        })
        st.dataframe(
            display_df.set_index("Segment"),
            use_container_width=True,
            height=400
        )

    st.divider()

    # ─── Customer Map ─────────────────────────────────────────────────────────
    st.subheader("Customer Map: Frequency vs Monetary Value")
    
    if len(seg) > 0:
        sample = seg.sample(min(3000, len(seg)), random_state=42)
        fig = px.scatter(
            sample,
            x="frequency",
            y="monetary",
            color="segment",
            hover_data=["recency"] + diversity_cols if diversity_cols else ["recency"],
            color_discrete_sequence=COLOR_SCALE,
            labels={
                "frequency": "Number of Orders",
                "monetary": "Total Estimated Spend ($)",
                "recency": "Average Days Between Orders",
            },
            opacity=0.7,
        )
        fig.update_layout(
            height=500,
            plot_bgcolor="white",
            paper_bgcolor="white"
        )
        fig.update_xaxes(showgrid=True, gridcolor="#f0f0f0")
        fig.update_yaxes(showgrid=True, gridcolor="#f0f0f0")
        st.plotly_chart(fig, use_container_width=True)

    # ─── Monetary Distribution ────────────────────────────────────────────────
    st.subheader("Monetary Value Distribution by Segment")
    fig = px.box(
        seg,
        x="segment",
        y="monetary",
        color="segment",
        color_discrete_sequence=COLOR_SCALE,
        labels={"monetary": "Total Estimated Spend ($)", "segment": "Segment"},
        points="outliers",
    )
    fig.update_layout(
        height=400,
        showlegend=False,
        plot_bgcolor="white",
        paper_bgcolor="white"
    )
    fig.update_xaxes(showgrid=False)
    fig.update_yaxes(showgrid=True, gridcolor="#f0f0f0")
    st.plotly_chart(fig, use_container_width=True)

    # ─── Diversity Metrics ────────────────────────────────────────────────────
    if diversity_cols:
        st.divider()
        st.subheader("Basket Diversity Analysis")
        
        col1, col2 = st.columns(2)
        
        with col1:
            if "unique_products" in seg.columns:
                fig = px.box(
                    seg,
                    x="segment",
                    y="unique_products",
                    color="segment",
                    color_discrete_sequence=COLOR_SCALE,
                    labels={
                        "unique_products": "Unique Products Purchased",
                        "segment": "Segment"
                    }
                )
                fig.update_layout(
                    height=350,
                    showlegend=False,
                    plot_bgcolor="white",
                    paper_bgcolor="white"
                )
                st.plotly_chart(fig, use_container_width=True)
        
        with col2:
            if "diversity_index" in seg.columns:
                fig = px.box(
                    seg,
                    x="segment",
                    y="diversity_index",
                    color="segment",
                    color_discrete_sequence=COLOR_SCALE,
                    labels={
                        "diversity_index": "Diversity Index (Shannon)",
                        "segment": "Segment"
                    }
                )
                fig.update_layout(
                    height=350,
                    showlegend=False,
                    plot_bgcolor="white",
                    paper_bgcolor="white"
                )
                st.plotly_chart(fig, use_container_width=True)

    # ─── Key Insight ──────────────────────────────────────────────────────────
    create_insight_box(
        "<strong>Strategic Implications:</strong> High-frequency, high-monetary segments "
        "concentrate a significant share of revenue. These are prime candidates for value-added "
        "bundles and loyalty programs. Low-frequency segments can be targeted with reactivation "
        "offers to increase engagement."
    )

# =============================================================================
# PAGE 3: PRODUCT ASSOCIATIONS
# =============================================================================
elif page == "Product Associations":
    st.title("Product Associations & Bundles")
    st.markdown("Association rules extracted via FP-Growth on Instacart market baskets.")
    st.divider()

    if data_missing("rules", "results/association_rules.csv"):
        st.stop()

    rules = data["rules"].copy()
    if rules.empty:
        st.info("Association rules table is empty.")
        st.stop()

    # ─── Metric Explanations ──────────────────────────────────────────────────
    with st.expander("Understanding Association Metrics", expanded=False):
        col1, col2 = st.columns(2)
        
        with col1:
            show_kpi_help(
                "Support",
                "Frequency of itemset occurrence in transactions. Support = 0.05 means the pattern "
                "appears in 5% of orders. Higher values indicate more common patterns."
            )
            show_kpi_help(
                "Confidence",
                "Probability of purchasing B given that A is already in the basket. "
                "Confidence(A→B) = 0.80 means 80% of customers who buy A also buy B."
            )
        
        with col2:
            show_kpi_help(
                "Lift",
                "Measures association strength versus random chance. Lift > 1: Positive association "
                "(A and B go together). Lift = 1: Independence. Lift < 1: Negative association. "
                "Lift = 2.5 means purchasing B is 2.5x more likely with A."
            )
            show_kpi_help(
                "Utility Score",
                "Composite score: Support × Confidence × Lift. Used to prioritize rules by "
                "potential business impact. Higher values indicate more actionable rules."
            )

    # ─── Interactive Filters ──────────────────────────────────────────────────
    st.subheader("Quality Filters")
    col1, col2, col3 = st.columns(3)
    
    with col1:
        min_support = st.slider(
            "Minimum Support",
            0.01, 0.3, 0.03, 0.01,
            help="Minimum frequency of itemset in transactions"
        )
    with col2:
        min_confidence = st.slider(
            "Minimum Confidence",
            0.1, 1.0, 0.30, 0.05,
            help="Minimum probability of association"
        )
    with col3:
        min_lift = st.slider(
            "Minimum Lift",
            1.0, 10.0, 1.2, 0.1,
            help="Association strength (>1 = positive)"
        )

    filtered = rules[
        (rules["support"] >= min_support)
        & (rules["confidence"] >= min_confidence)
        & (rules["lift"] >= min_lift)
    ]

    st.markdown(f"**{len(filtered)} rules** meet the selected criteria.")

    st.divider()

    # ─── Top Rules ────────────────────────────────────────────────────────────
    st.subheader("Top 20 Association Rules (by Lift)")
    
    if (
        "antecedents_str" in filtered.columns
        and "consequents_str" in filtered.columns
        and not filtered.empty
    ):
        display_rules = (
            filtered.sort_values("lift", ascending=False)
            .head(20)[
                ["antecedents_str", "consequents_str", "support", "confidence", "lift"]
            ]
            .rename(
                columns={
                    "antecedents_str": "If Customer Buys",
                    "consequents_str": "They Will Likely Buy",
                    "support": "Support",
                    "confidence": "Confidence",
                    "lift": "Lift",
                }
            )
        )
        display_rules[["Support", "Confidence", "Lift"]] = display_rules[
            ["Support", "Confidence", "Lift"]
        ].round(3)
        
        st.dataframe(display_rules, use_container_width=True, height=450)
    else:
        st.info("No rules match the current filters.")

    st.divider()

    # ─── Rule Map ─────────────────────────────────────────────────────────────
    if not filtered.empty:
        st.subheader("Rule Map: Support vs Confidence")
        fig = px.scatter(
            filtered,
            x="support",
            y="confidence",
            color="lift",
            size="lift",
            hover_data=["antecedents_str", "consequents_str"],
            color_continuous_scale=[[0, COLORS["warning"]], [0.5, COLORS["secondary"]], [1, COLORS["accent"]]],
            labels={"support": "Support", "confidence": "Confidence", "lift": "Lift"},
            opacity=0.75,
        )
        fig.update_layout(
            height=480,
            plot_bgcolor="white",
            paper_bgcolor="white"
        )
        fig.update_xaxes(showgrid=True, gridcolor="#f0f0f0")
        fig.update_yaxes(showgrid=True, gridcolor="#f0f0f0")
        st.plotly_chart(fig, use_container_width=True)

    # ─── High-Utility Rules ───────────────────────────────────────────────────
    if data["utility"] is not None and not data["utility"].empty:
        st.divider()
        st.subheader("High-Utility Rules (Premium Basket Focus)")
        
        util_rules = data["utility"].copy()
        util_rules = util_rules.sort_values("utility_score", ascending=False).head(10)
        util_rules[
            ["support", "confidence", "lift", "utility_score"]
        ] = util_rules[["support", "confidence", "lift", "utility_score"]].round(3)
        
        display_util = util_rules[
            ["itemset_str", "support", "confidence", "lift", "utility_score"]
        ].rename(columns={
            "itemset_str": "Association Rule",
            "support": "Support",
            "confidence": "Confidence",
            "lift": "Lift",
            "utility_score": "Utility Score"
        })
        
        st.dataframe(display_util, use_container_width=True)
        
        create_insight_box(
            "<strong>High-Utility Rules:</strong> These rules are mined exclusively from "
            "high-value orders and ranked by composite score (support × confidence × lift). "
            "They represent the most relevant bundles for revenue-focused promotions."
        )

    # ─── Department Analysis ──────────────────────────────────────────────────
    if data["dept_summary"] is not None and not data["dept_summary"].empty:
        st.divider()
        st.subheader("Department-Level Analysis")
        
        dept_sum = data["dept_summary"].copy()
        dept_sum = dept_sum.sort_values("rules_count", ascending=False)
        
        col1, col2 = st.columns(2)
        
        with col1:
            fig = px.bar(
                dept_sum.head(10),
                x="rules_count",
                y="department",
                orientation="h",
                color="avg_lift",
                color_continuous_scale=[[0, COLORS["secondary"]], [1, COLORS["accent"]]],
                labels={
                    "rules_count": "Number of Rules",
                    "department": "",
                    "avg_lift": "Average Lift"
                }
            )
            fig.update_layout(
                height=400,
                plot_bgcolor="white",
                paper_bgcolor="white"
            )
            st.plotly_chart(fig, use_container_width=True)
        
        with col2:
            st.dataframe(
                dept_sum[["department", "rules_count", "avg_lift", "max_lift"]].rename(columns={
                    "department": "Department",
                    "rules_count": "Rules",
                    "avg_lift": "Avg Lift",
                    "max_lift": "Max Lift"
                }).round(2),
                use_container_width=True,
                height=400
            )

# =============================================================================
# PAGE 4: REVENUE SIMULATION
# =============================================================================
elif page == "Revenue Simulation":
    st.title("Revenue Simulation from Product Bundles")
    st.markdown("Estimate the financial impact of deploying association rule-based bundles.")
    st.divider()

    if data_missing("revenue", "results/revenue_simulation.csv"):
        st.stop()

    rev = data["revenue"].copy()
    if rev.empty:
        st.info("Revenue simulation table is empty.")
        st.stop()

    # ─── Simulation Explanations ──────────────────────────────────────────────
    with st.expander("Understanding Revenue Simulation", expanded=False):
        col1, col2 = st.columns(2)
        
        with col1:
            show_kpi_help(
                "Revenue Uplift",
                "Additional revenue generated by the lift effect of associations. "
                "Calculated as: New Orders × Average Basket × (Lift - 1). "
                "Measures incremental sales from recommendations."
            )
            show_kpi_help(
                "Discount Cost",
                "Total cost of discounts applied to promote bundles. "
                "Calculated as: New Orders × Average Price × Discount %. "
                "Represents marketing investment."
            )
        
        with col2:
            show_kpi_help(
                "Net Revenue Gain",
                "NET incremental revenue after deducting promotion costs. "
                "Net Gain = Revenue Uplift - Discount Cost. "
                "Key profitability indicator for bundle strategy."
            )
            show_kpi_help(
                "ROI (Return on Investment)",
                "Return on investment percentage. "
                "ROI = (Net Gain / Discount Cost) × 100. "
                "ROI of 250% means each dollar invested generates $2.50 net gain."
            )

    # ─── Interactive Parameters ───────────────────────────────────────────────
    st.subheader("Simulation Parameters")
    
    col1, col2, col3 = st.columns(3)
    with col1:
        n_customers = st.number_input(
            "Customer Base Size",
            min_value=1_000,
            max_value=500_000,
            value=50_000,
            step=1_000,
            help="Total active customers"
        )
    with col2:
        avg_order_val = st.number_input(
            "Average Basket Value ($)",
            min_value=5.0,
            max_value=200.0,
            value=25.0,
            step=1.0,
            help="Average order amount"
        )
    with col3:
        discount_pct = st.slider(
            "Bundle Discount (%)",
            5, 30, 10,
            help="Discount percentage on bundles"
        )

    # ─── Recalculate Metrics ──────────────────────────────────────────────────
    rev_sim = rev.copy()
    rev_sim["est_new_orders"] = (
        rev_sim["support"] * n_customers * rev_sim["confidence"]
    ).astype(int)
    rev_sim["revenue_from_lift"] = (
        rev_sim["est_new_orders"] * avg_order_val * (rev_sim["lift"] - 1)
    )
    rev_sim["discount_cost"] = (
        rev_sim["est_new_orders"] * avg_order_val * (discount_pct / 100)
    )
    rev_sim["net_revenue_gain"] = (
        rev_sim["revenue_from_lift"] - rev_sim["discount_cost"]
    )
    rev_sim["roi_pct"] = (
        (rev_sim["net_revenue_gain"] / (rev_sim["discount_cost"] + 1e-6)) * 100
    ).round(1)
    rev_sim = rev_sim.sort_values("net_revenue_gain", ascending=False)

    # ─── Aggregate KPIs ───────────────────────────────────────────────────────
    total_gain = rev_sim["net_revenue_gain"].sum()
    total_cost = rev_sim["discount_cost"].sum()
    total_lift_rev = rev_sim["revenue_from_lift"].sum()
    avg_roi = rev_sim["roi_pct"].mean()

    st.divider()
    
    col1, col2, col3, col4 = st.columns(4)
    col1.metric(
        "Total Revenue Uplift",
        f"${total_lift_rev:,.0f}",
        help="Additional revenue from lift"
    )
    col2.metric(
        "Total Discount Cost",
        f"${total_cost:,.0f}",
        help="Promotional investment"
    )
    col3.metric(
        "Net Incremental Revenue",
        f"${total_gain:,.0f}",
        delta=f"+{((total_gain/total_cost)*100):.0f}% ROI" if total_cost > 0 else "",
        help="Net profit after discounts"
    )
    col4.metric(
        "Average Bundle ROI",
        f"{avg_roi:.0f}%",
        help="Average return on investment"
    )

    st.divider()

    # ─── Top Bundles ──────────────────────────────────────────────────────────
    st.subheader("Top 15 Bundles by Net Revenue Gain")
    
    top15 = rev_sim.head(15).copy()
    top15["bundle"] = (
        top15["antecedents_str"] + " → " + top15["consequents_str"]
    ).str.slice(0, 65)

    fig = px.bar(
        top15.sort_values("net_revenue_gain"),
        x="net_revenue_gain",
        y="bundle",
        orientation="h",
        color="roi_pct",
        color_continuous_scale=[[0, COLORS["danger"]], [0.3, COLORS["warning"]], [0.7, COLORS["accent"]]],
        labels={
            "net_revenue_gain": "Net Revenue Gain ($)",
            "bundle": "",
            "roi_pct": "ROI (%)",
        },
    )
    fig.update_layout(
        height=520,
        plot_bgcolor="white",
        paper_bgcolor="white"
    )
    fig.update_xaxes(showgrid=True, gridcolor="#f0f0f0")
    st.plotly_chart(fig, use_container_width=True)

    st.divider()

    # ─── Revenue vs Cost ──────────────────────────────────────────────────────
    st.subheader("Revenue Uplift vs Discount Cost (Top 100)")
    
    fig = px.scatter(
        rev_sim.head(100),
        x="discount_cost",
        y="revenue_from_lift",
        size="est_new_orders",
        color="roi_pct",
        hover_data=["antecedents_str", "consequents_str"],
        color_continuous_scale=[[0, COLORS["danger"]], [0.5, COLORS["warning"]], [1, COLORS["accent"]]],
        labels={
            "discount_cost": "Discount Cost ($)",
            "revenue_from_lift": "Revenue Uplift ($)",
            "roi_pct": "ROI (%)"
        },
        opacity=0.7
    )
    
    # Break-even line
    max_val = float(
        max(rev_sim["discount_cost"].max(), rev_sim["revenue_from_lift"].max())
    )
    fig.add_trace(
        go.Scatter(
            x=[0, max_val],
            y=[0, max_val],
            mode="lines",
            line=dict(dash="dash", color=COLORS["neutral"], width=2),
            name="Break-even",
        )
    )
    
    fig.update_layout(
        height=480,
        plot_bgcolor="white",
        paper_bgcolor="white"
    )
    fig.update_xaxes(showgrid=True, gridcolor="#f0f0f0")
    fig.update_yaxes(showgrid=True, gridcolor="#f0f0f0")
    st.plotly_chart(fig, use_container_width=True)

    # ─── Key Insight ──────────────────────────────────────────────────────────
    create_insight_box(
        "<strong>Interpretation:</strong> Bundles above the break-even line generate positive "
        "net profit. The farther a point is above this line, the higher the ROI. Prioritize "
        "bundles with ROI > 200% and significant estimated order volume for maximum impact."
    )

    # ─── Detailed Table ───────────────────────────────────────────────────────
    with st.expander("Detailed Simulation Table"):
        st.dataframe(
            rev_sim[
                [
                    "antecedents_str",
                    "consequents_str",
                    "est_new_orders",
                    "revenue_from_lift",
                    "discount_cost",
                    "net_revenue_gain",
                    "roi_pct",
                ]
            ]
            .rename(
                columns={
                    "antecedents_str": "If Buys",
                    "consequents_str": "Also Buys",
                    "est_new_orders": "Estimated Orders",
                    "revenue_from_lift": "Revenue Uplift",
                    "discount_cost": "Discount Cost",
                    "net_revenue_gain": "Net Gain",
                    "roi_pct": "ROI (%)",
                }
            )
            .round(2),
            use_container_width=True,
            height=400
        )

# =============================================================================
# PAGE 5: PROMOTION ROI
# =============================================================================
elif page == "Promotion ROI":
    st.title("Promotion Efficiency Analysis")
    st.markdown(
        "Comparison between targeted, data-driven discounts and non-targeted blanket discounts."
    )
    st.divider()

    if data_missing("promotion", "results/promotion_efficiency.csv"):
        st.stop()

    promo = data["promotion"].copy()
    if promo.empty:
        st.info("Promotion efficiency table is empty.")
        st.stop()

    # ─── Promotion Explanations ───────────────────────────────────────────────
    with st.expander("Understanding Promotion Efficiency", expanded=False):
        col1, col2 = st.columns(2)
        
        with col1:
            show_kpi_help(
                "Blanket Discount",
                "Traditional strategy: same discount for ALL customers without distinction. "
                "Reduces margin for everyone, including those who would have purchased anyway."
            )
            show_kpi_help(
                "Targeted Discount",
                "Data-driven strategy: personalized discounts based on segments and product "
                "associations. Targets only customers with high lift potential."
            )
        
        with col2:
            show_kpi_help(
                "Revenue Lift",
                "Revenue increase generated by the lift effect (incremental purchases). "
                "Higher for targeted promotions as they genuinely stimulate new purchases."
            )
            show_kpi_help(
                "Targeting Advantage",
                "P&L difference between targeted and blanket approaches. "
                "Positive = targeting generates more profit. "
                "Measures ROI of analytics investment."
            )

    # ─── Promotion Parameters ─────────────────────────────────────────────────
    st.subheader("Promotion Parameters")
    
    col1, col2, col3 = st.columns(3)
    with col1:
        blanket_disc = st.slider(
            "Blanket Discount (%)",
            5, 30, 15,
            help="Discount applied to all without distinction"
        )
    with col2:
        targeted_disc = st.slider(
            "Targeted Discount (%)",
            5, 20, 10,
            help="Discount applied only to targeted segments"
        )
    with col3:
        targeted_lift = st.slider(
            "Expected Targeting Lift",
            1.05, 2.0, 1.25, 0.05,
            help="Sales multiplier from targeting"
        )

    # ─── Recalculate with Parameters ──────────────────────────────────────────
    scale_blanket = blanket_disc / 15
    scale_targeted = targeted_disc / 10
    scale_lift = targeted_lift / 1.25

    promo["blanket_net_gain"] = -(promo["blanket_cost"] * scale_blanket)
    promo["targeted_revenue_lift"] = promo["targeted_gain"] * scale_lift
    promo["targeted_discount_cost"] = promo["targeted_cost"] * scale_targeted
    promo["targeted_net_gain"] = (
        promo["targeted_revenue_lift"] - promo["targeted_discount_cost"]
    )
    promo["targeting_advantage"] = promo["targeted_net_gain"] - promo["blanket_net_gain"]

    # ─── Aggregate KPIs ───────────────────────────────────────────────────────
    total_targeted = promo["targeted_net_gain"].sum()
    total_blanket = promo["blanket_net_gain"].sum()
    advantage = promo["targeting_advantage"].sum()

    st.divider()
    
    col1, col2, col3 = st.columns(3)
    col1.metric(
        "Blanket P&L",
        f"${total_blanket:,.0f}",
        help="Profit & Loss with discount for all"
    )
    col2.metric(
        "Targeted P&L",
        f"${total_targeted:,.0f}",
        delta=f"+${total_targeted - total_blanket:,.0f} vs blanket",
        help="Profit & Loss with data-driven targeting"
    )
    col3.metric(
        "Targeting Advantage",
        f"${advantage:,.0f}",
        delta=f"+{((advantage/abs(total_blanket))*100):.0f}%" if total_blanket != 0 else "",
        help="Gain from targeting vs traditional approach"
    )

    st.divider()

    # ─── Segment Comparison ───────────────────────────────────────────────────
    st.subheader("P&L by Customer Segment")
    
    fig = go.Figure()
    fig.add_trace(
        go.Bar(
            name="Blanket Discount",
            x=promo["segment"],
            y=promo["blanket_net_gain"],
            marker_color=COLORS["danger"],
        )
    )
    fig.add_trace(
        go.Bar(
            name="Targeted Discount",
            x=promo["segment"],
            y=promo["targeted_net_gain"],
            marker_color=COLORS["accent"],
        )
    )
    fig.update_layout(
        barmode="group",
        height=450,
        yaxis_title="Net P&L ($)",
        xaxis_title="Customer Segment",
        plot_bgcolor="white",
        paper_bgcolor="white"
    )
    fig.update_xaxes(showgrid=False)
    fig.update_yaxes(showgrid=True, gridcolor="#f0f0f0")
    st.plotly_chart(fig, use_container_width=True)

    st.divider()

    # ─── Cost vs Lift ─────────────────────────────────────────────────────────
    st.subheader("Cost vs Revenue Lift by Segment")
    
    melted = promo.melt(
        id_vars="segment",
        value_vars=["targeted_discount_cost", "targeted_revenue_lift"],
        var_name="Component",
        value_name="Amount",
    )
    melted["Component"] = melted["Component"].map({
        "targeted_discount_cost": "Discount Cost",
        "targeted_revenue_lift": "Revenue Lift"
    })
    
    fig = px.bar(
        melted,
        x="segment",
        y="Amount",
        color="Component",
        barmode="group",
        color_discrete_map={
            "Discount Cost": COLORS["danger"],
            "Revenue Lift": COLORS["accent"],
        },
        labels={"segment": "Customer Segment", "Amount": "Amount ($)"},
    )
    fig.update_layout(
        height=400,
        plot_bgcolor="white",
        paper_bgcolor="white"
    )
    fig.update_xaxes(showgrid=False)
    fig.update_yaxes(showgrid=True, gridcolor="#f0f0f0")
    st.plotly_chart(fig, use_container_width=True)

    # ─── Key Insight ──────────────────────────────────────────────────────────
    create_insight_box(
        "<strong>Winning Strategy:</strong> Blanket discounts reduce margin for ALL customers, "
        "including loyal ones who would purchase anyway. Targeted promotions concentrate investment "
        "where lift is maximized, transforming a cost center into a controlled growth lever. "
        "Data-driven targeting can generate 40-60% additional P&L."
    )

    # ─── Detailed Table ───────────────────────────────────────────────────────
    with st.expander("Detailed Segment Table"):
        display_promo = promo.round(0)[
            [
                "segment",
                "customers",
                "avg_spend",
                "blanket_net_gain",
                "targeted_discount_cost",
                "targeted_revenue_lift",
                "targeted_net_gain",
                "targeting_advantage",
            ]
        ]
        display_promo.columns = [
            "Segment",
            "Customers",
            "Avg Spend",
            "Blanket P&L",
            "Targeted Cost",
            "Targeted Lift",
            "Targeted P&L",
            "Advantage",
        ]
        st.dataframe(display_promo, use_container_width=True, height=350)

# ─── Footer ───────────────────────────────────────────────────────────────────
st.divider()
st.markdown(
    f"""
    <div style='text-align: center; color: {COLORS["neutral"]}; padding: 20px;'>
        <p><strong>Retail Insights Dashboard</strong> | Powered by Python, Streamlit & Plotly</p>
        <p style='font-size: 0.85em;'>Data Source: Instacart Market Basket Analysis Dataset</p>
    </div>
    """,
    unsafe_allow_html=True
)